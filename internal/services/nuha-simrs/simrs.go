package nuha_simrs

import (
	"context"
	"fmt"
	"log/slog"
	"strings"
	"time"

	"github.com/BioSystems-Indonesia/TAMALabs/internal/constant"
	"github.com/BioSystems-Indonesia/TAMALabs/internal/entity"
	patientrepo "github.com/BioSystems-Indonesia/TAMALabs/internal/repository/sql/patient"
	testTypeRepo "github.com/BioSystems-Indonesia/TAMALabs/internal/repository/sql/test_type"
	workOrder "github.com/BioSystems-Indonesia/TAMALabs/internal/repository/sql/work_order"
	workOrderUC "github.com/BioSystems-Indonesia/TAMALabs/internal/usecase/work_order"
)

type SIMRSNuha struct {
	BaseURL       string
	SessionID     string
	workOrderRepo *workOrder.WorkOrderRepository
	workOrderUC   *workOrderUC.WorkOrderUseCase
	patientRepo   *patientrepo.PatientRepository
	testTypeRepo  *testTypeRepo.Repository
}

func NewSIMRSNuha(
	baseURL string,
	sessionID string,
	workOrderRepo *workOrder.WorkOrderRepository,
	workOrderUC *workOrderUC.WorkOrderUseCase,
	patientrepo *patientrepo.PatientRepository,
	testTypeRepo *testTypeRepo.Repository,
) *SIMRSNuha {
	return &SIMRSNuha{
		BaseURL:       baseURL,
		SessionID:     sessionID,
		workOrderRepo: workOrderRepo,
		workOrderUC:   workOrderUC,
		patientRepo:   patientrepo,
		testTypeRepo:  testTypeRepo,
	}
}

func (c *SIMRSNuha) GetLabOrder(ctx context.Context) error {
	nuhaService := NewNuhaService(c.BaseURL)

	// Get today's date in YYYY-MM-DD format
	today := time.Now().Format("2006-01-02")

	req := LabListRequest{
		SessionID: c.SessionID,
		ValidFrom: today,
		ValidTo:   today,
	}

	result, err := nuhaService.GetLabList(ctx, req)
	if err != nil {
		return fmt.Errorf("failed to get lab list: %w", err)
	}

	slog.InfoContext(ctx, "Retrieved lab orders from Nuha SIMRS",
		"count", len(result.Response.List),
		"date", today)

	for _, labReg := range result.Response.List {
		if err := c.processLabRegistration(ctx, labReg); err != nil {
			slog.ErrorContext(ctx, "Failed to process lab registration",
				"lab_number", labReg.LabNumber,
				"patient_name", labReg.PatientName,
				"error", err)
			continue
		}
	}

	return nil
}

func (c *SIMRSNuha) processLabRegistration(ctx context.Context, labReg LabRegistration) error {
	patient, err := c.findOrCreatePatient(ctx, labReg)
	if err != nil {
		return fmt.Errorf("failed to find/create patient: %w", err)
	}

	slog.InfoContext(ctx, "Patient processed",
		"patient_id", patient.ID,
		"name", patient.FirstName+" "+patient.LastName,
		"mr_number", labReg.MedicalRecordNo)

	testTypes, err := c.parseTestTypes(ctx, labReg.TestList)
	if err != nil {
		return fmt.Errorf("failed to parse test types: %w", err)
	}

	if len(testTypes) == 0 {
		slog.WarnContext(ctx, "No valid test types found for lab registration", "lab_number", labReg.LabNumber)
		return nil
	}

	labNumberStr := fmt.Sprintf("NUHA-%d", labReg.LabNumber)
	existingWorkOrder, err := c.workOrderRepo.GetBySIMRSBarcode(ctx, labNumberStr)
	if err == nil {
		// Work order exists, update it
		slog.InfoContext(ctx, "Work order already exists, updating",
			"work_order_id", existingWorkOrder.ID,
			"lab_number", labNumberStr)
		return c.updateWorkOrder(ctx, existingWorkOrder, patient, testTypes, labReg)
	}

	workOrderReq := &entity.WorkOrderCreateRequest{
		PatientID:           patient.ID,
		TestTypes:           testTypes,
		CreatedBy:           int64(constant.CreatedBySystem),
		BarcodeSIMRS:        labNumberStr,
		MedicalRecordNumber: labReg.MedicalRecordNo,
		Barcode:             "", // Will be generated by system
		DoctorIDs:           []int64{},
		AnalyzerIDs:         []int64{},
	}

	workOrderID, err := c.workOrderUC.Create(workOrderReq)
	if err != nil {
		return fmt.Errorf("failed to create work order: %w", err)
	}

	slog.InfoContext(ctx, "Work order created successfully",
		"work_order_id", workOrderID,
		"lab_number", labNumberStr,
		"patient_id", patient.ID,
		"test_count", len(testTypes))

	return nil
}

func (c *SIMRSNuha) findOrCreatePatient(ctx context.Context, labReg LabRegistration) (entity.Patient, error) {
	if labReg.MedicalRecordNo != "" {
		var existingPatient entity.Patient
		err := c.patientRepo.FindByMedicalRecordNumber(ctx, labReg.MedicalRecordNo, &existingPatient)
		if err == nil {
			return existingPatient, nil
		}
	}

	firstName, lastName := parsePatientName(labReg.PatientName)

	sex := entity.PatientSexUnknown
	switch strings.ToUpper(labReg.Gender) {
	case "L", "LAKI-LAKI", "M", "MALE":
		sex = entity.PatientSexMale
	case "P", "PEREMPUAN", "F", "FEMALE":
		sex = entity.PatientSexFemale
	}

	patient := &entity.Patient{
		FirstName:           firstName,
		LastName:            lastName,
		Birthdate:           labReg.BirthDate,
		Sex:                 sex,
		MedicalRecordNumber: labReg.MedicalRecordNo,
		Address:             labReg.Address,
		PhoneNumber:         "",
		Location:            labReg.Room,
	}

	result, err := c.patientRepo.FirstOrCreate(patient)
	if err != nil {
		return entity.Patient{}, fmt.Errorf("failed to create patient: %w", err)
	}

	if result.MedicalRecordNumber == "" && labReg.MedicalRecordNo != "" {
		result.MedicalRecordNumber = labReg.MedicalRecordNo
		if err := c.patientRepo.Update(&result); err != nil {
			slog.WarnContext(ctx, "Failed to update patient medical record number", "error", err)
		}
	}

	return result, nil
}

func (c *SIMRSNuha) parseTestTypes(ctx context.Context, testList []LabTest) ([]entity.WorkOrderCreateRequestTestType, error) {
	var testTypes []entity.WorkOrderCreateRequestTestType
	seenTests := make(map[int]bool)

	for _, labTest := range testList {
		if labTest.TestType == "p" && len(labTest.TestDetails) > 0 {
			slog.InfoContext(ctx, "Processing package test",
				"package_name", labTest.TestName,
				"package_id", labTest.TestID,
				"detail_count", len(labTest.TestDetails))

			for _, detail := range labTest.TestDetails {
				if seenTests[detail.TestID] {
					continue
				}
				seenTests[detail.TestID] = true

				testIDStr := fmt.Sprintf("%d", detail.TestID)
				testType, err := c.testTypeRepo.FindOneByAliasCode(ctx, testIDStr)
				if err != nil {
					testType, err = c.testTypeRepo.FindOneByCode(ctx, detail.TestName)
					if err != nil {
						slog.WarnContext(ctx, "Test type not found in system (from package)",
							"package_name", labTest.TestName,
							"test_name", detail.TestName,
							"test_id", detail.TestID,
							"searched_alias_code", testIDStr)
						continue
					}
					slog.InfoContext(ctx, "Test type found by code/name (from package)",
						"package_name", labTest.TestName,
						"test_name", detail.TestName,
						"test_id", detail.TestID,
						"test_type_id", testType.ID)
				} else {
					slog.InfoContext(ctx, "Test type found by alias code (from package)",
						"package_name", labTest.TestName,
						"test_name", detail.TestName,
						"test_id", detail.TestID,
						"test_type_id", testType.ID,
						"alias_code", testType.AliasCode)
				}

				testTypes = append(testTypes, entity.WorkOrderCreateRequestTestType{
					TestTypeID:   int64(testType.ID),
					TestTypeCode: testType.Code,
					SpecimenType: testType.GetFirstType(),
				})
			}
		} else {
			if seenTests[labTest.TestID] {
				continue
			}
			seenTests[labTest.TestID] = true

			testIDStr := fmt.Sprintf("%d", labTest.TestID)

			testType, err := c.testTypeRepo.FindOneByAliasCode(ctx, testIDStr)
			if err != nil {
				testType, err = c.testTypeRepo.FindOneByCode(ctx, labTest.TestName)
				if err != nil {
					slog.WarnContext(ctx, "Test type not found in system",
						"test_name", labTest.TestName,
						"test_id", labTest.TestID,
						"searched_alias_code", testIDStr,
						"searched_by", "alias_code (TestID) and code (TestName)")
					continue
				}
				slog.InfoContext(ctx, "Test type found by code/name (not by alias code)",
					"test_name", labTest.TestName,
					"test_id", labTest.TestID,
					"test_type_id", testType.ID,
					"test_type_code", testType.Code)
			} else {
				slog.InfoContext(ctx, "Test type found by alias code (TestID)",
					"test_name", labTest.TestName,
					"test_id", labTest.TestID,
					"test_type_id", testType.ID,
					"test_type_code", testType.Code,
					"alias_code", testType.AliasCode)
			}

			testTypes = append(testTypes, entity.WorkOrderCreateRequestTestType{
				TestTypeID:   int64(testType.ID),
				TestTypeCode: testType.Code,
				SpecimenType: testType.GetFirstType(),
			})
		}
	}

	return testTypes, nil
}

func (c *SIMRSNuha) updateWorkOrder(
	ctx context.Context,
	existingWorkOrder entity.WorkOrder,
	patient entity.Patient,
	newTestTypes []entity.WorkOrderCreateRequestTestType,
	labReg LabRegistration,
) error {
	existingTestTypeIDs := make(map[int64]bool)
	for _, specimen := range existingWorkOrder.Specimen {
		for _, obsReq := range specimen.ObservationRequest {
			existingTestTypeIDs[int64(obsReq.TestType.ID)] = true
		}
	}

	var testsToAdd []entity.WorkOrderCreateRequestTestType
	for _, testType := range newTestTypes {
		if !existingTestTypeIDs[testType.TestTypeID] {
			testsToAdd = append(testsToAdd, testType)
		}
	}

	if len(testsToAdd) == 0 {
		slog.InfoContext(ctx, "No new tests to add to existing work order",
			"work_order_id", existingWorkOrder.ID)
		return nil
	}

	allTestTypes := make([]entity.WorkOrderCreateRequestTestType, 0)
	for _, specimen := range existingWorkOrder.Specimen {
		for _, obsReq := range specimen.ObservationRequest {
			allTestTypes = append(allTestTypes, entity.WorkOrderCreateRequestTestType{
				TestTypeID:   int64(obsReq.TestType.ID),
				TestTypeCode: obsReq.TestType.Code,
				SpecimenType: specimen.Type,
			})
		}
	}
	allTestTypes = append(allTestTypes, testsToAdd...)

	workOrderReq := &entity.WorkOrderCreateRequest{
		PatientID:           patient.ID,
		TestTypes:           allTestTypes,
		CreatedBy:           int64(constant.CreatedBySystem),
		BarcodeSIMRS:        fmt.Sprintf("NUHA-%d", labReg.LabNumber),
		MedicalRecordNumber: labReg.MedicalRecordNo,
		Barcode:             existingWorkOrder.Barcode,
		DoctorIDs:           existingWorkOrder.DoctorIDs,
		AnalyzerIDs:         existingWorkOrder.AnalyzerIDs,
	}

	_, err := c.workOrderRepo.Edit(int(existingWorkOrder.ID), workOrderReq)
	if err != nil {
		return fmt.Errorf("failed to update work order: %w", err)
	}

	slog.InfoContext(ctx, "Work order updated successfully",
		"work_order_id", existingWorkOrder.ID,
		"added_tests", len(testsToAdd),
		"total_tests", len(allTestTypes))

	return nil
}

// SendResultToNuha sends test result to Nuha SIMRS
func (c *SIMRSNuha) SendResultToNuha(
	ctx context.Context,
	labNumber int,
	testID int,
	testName string,
	resultValue string,
	unit string,
	referenceRange string,
	abnormalFlag string,
	resultText string,
	packageID int,
	index int,
	insertedUser string,
	insertedIP string,
) error {
	nuhaService := NewNuhaService(c.BaseURL)

	req := InsertResultRequest{
		SessionID:    c.SessionID,
		NoLab:        labNumber,
		NamaTest:     testName,
		Hasil:        resultValue,
		Satuan:       unit,
		NilaiRujukan: referenceRange,
		Abnormal:     abnormalFlag,
		Keterangan:   "",
		Catatan:      "",
		TestID:       testID,
		HasilText:    resultText,
		PaketID:      packageID,
		Spasi:        "",
		Index:        index,
		InsertedUser: insertedUser,
		InsertedIP:   insertedIP,
	}

	result, err := nuhaService.InsertResult(ctx, req)
	if err != nil {
		return fmt.Errorf("failed to insert result to Nuha SIMRS: %w", err)
	}

	slog.InfoContext(ctx, "Result sent to Nuha SIMRS successfully",
		"lab_number", labNumber,
		"test_id", testID,
		"test_name", testName,
		"status", result.Response.Status,
		"message", result.Response.Message)

	return nil
}

// SendWorkOrderResults sends all test results from a work order to Nuha SIMRS
// This is a placeholder - will be implemented when result sending is needed
func (c *SIMRSNuha) SendWorkOrderResults(
	ctx context.Context,
	barcodeSIMRS string,
	insertedUser string,
	insertedIP string,
) error {
	// Extract lab number from SIMRS barcode (NUHA-12345 -> 12345)
	labNumberStr := strings.TrimPrefix(barcodeSIMRS, "NUHA-")
	labNumber := 0
	if _, err := fmt.Sscanf(labNumberStr, "%d", &labNumber); err != nil || labNumber == 0 {
		return fmt.Errorf("invalid SIMRS barcode format: %s", barcodeSIMRS)
	}

	slog.InfoContext(ctx, "SendWorkOrderResults called",
		"barcode_simrs", barcodeSIMRS,
		"lab_number", labNumber,
		"inserted_user", insertedUser)

	// TODO: Implement full result sending logic
	// This requires getting work order with all observation results
	// and mapping them to Nuha SIMRS format

	return nil
}

func parsePatientName(fullName string) (firstName, lastName string) {
	parts := strings.Fields(fullName)
	if len(parts) == 0 {
		return "Unknown", ""
	}
	if len(parts) == 1 {
		return parts[0], ""
	}
	return parts[0], strings.Join(parts[1:], " ")
}
